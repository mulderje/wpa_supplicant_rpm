diff -up wpa_supplicant-0.6.4/src/drivers/driver_wext.c.really-disassoc wpa_supplicant-0.6.4/src/drivers/driver_wext.c
--- wpa_supplicant-0.6.4/src/drivers/driver_wext.c.really-disassoc	2009-05-12 12:25:08.000000000 -0400
+++ wpa_supplicant-0.6.4/src/drivers/driver_wext.c	2009-05-12 12:47:08.000000000 -0400
@@ -2069,13 +2069,49 @@ static int wpa_driver_wext_mlme(struct w
 	return ret;
 }
 
+static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv)
+{
+	struct iwreq iwr;
+	const u8 null_bssid[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+	u8 ssid[32];
+	int i;
+
+	/* Only force-disconnect when the card is in infrastructure mode,
+	 * otherwise the driver might interpret the cleared BSSID and random
+	 * SSID as an attempt to create a new ad-hoc network.
+	 */
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWMODE]");
+		iwr.u.mode = IW_MODE_INFRA;
+	}
+
+	if (iwr.u.mode == IW_MODE_INFRA) {
+		/*
+		 * Clear the BSSID selection and set a random SSID to make sure
+		 * the driver will not be trying to associate with something
+		 * even if it does not understand SIOCSIWMLME commands (or tries
+		 * to associate automatically after deauth/disassoc).
+		 */
+		wpa_driver_wext_set_bssid(drv, null_bssid);
+
+		for (i = 0; i < 32; i++)
+			ssid[i] = rand() & 0xFF;
+		wpa_driver_wext_set_ssid(drv, ssid, 32);
+	}
+}
 
 static int wpa_driver_wext_deauthenticate(void *priv, const u8 *addr,
 					  int reason_code)
 {
 	struct wpa_driver_wext_data *drv = priv;
+	int ret;
+
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
-	return wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+	wpa_driver_wext_disconnect(drv);
+	return ret;
 }
 
 
@@ -2083,9 +2119,12 @@ static int wpa_driver_wext_disassociate(
 					int reason_code)
 {
 	struct wpa_driver_wext_data *drv = priv;
+	int ret;
+
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
-	return wpa_driver_wext_mlme(drv, addr, IW_MLME_DISASSOC,
-				    reason_code);
+	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DISASSOC, reason_code);
+	wpa_driver_wext_disconnect(drv);
+	return ret;
 }
 
 
